● 🔍 Phân Tích Kỹ Thuật Thuật Toán Chọn Thuật Toán

  📊 Kiến Trúc Tổng Quan

  Thuật toán hoạt động theo pipeline 3 bước:
  1. Phân tích độ liên quan (analyzeQuestionRelevance)
  2. Phân loại câu hỏi (categorizeQuestion)
  3. Ra quyết định (selectAlgorithm)

  ---
  🧠 Bước 1: Phân Tích Độ Liên Quan (Relevance Analysis)

  Input: Câu hỏi người dùngOutput: relevanceScore, từ khóa trùng khớp,     
   chủ đề liên quan

  Công Thức Tính Điểm (Relevance Score):

  relevanceScore = keyword_score + topic_score + vocabulary_score

  Trong đó:
  - keyword_score = Σ(matched_important_keywords) × 3
  - topic_score = Σ(common_words_with_titles) × 2
  - vocabulary_score = Σ(partial_keyword_matches) × 1

  Ví Dụ Tính Toán:

  Câu hỏi: "Machine learning algorithms là gì?"

  1. Keyword matching:
     - "machine learning" ∈ important_keywords → +3 điểm
     - "algorithms" ∈ important_keywords → +3 điểm

  2. Topic matching:
     - So với title "Machine Learning cơ bản":
       - Common words: ["machine", "learning"] → +4 điểm (2×2)

  3. Vocabulary matching:
     - "algorithms" partial match với "algorithm" → +1 điểm

  Total relevanceScore = 3 + 3 + 4 + 1 = 11

  Threshold Logic:

  - relevanceScore > 2 → isKnowledgeRelated = true
  - Điểm cao → Có liên quan đến kiến thức đã học

  ---
  🏷️ Bước 2: Phân Loại Câu Hỏi (Question Categorization)

  Sử dụng Regex Pattern Matching:

  patterns = {
    definition: /^(.*)(là gì|what is|nghĩa là gì|định nghĩa|khái
  niệm)/,
    explanation: /^(tại sao|why|làm thế nào|how|giải thích)/,
    comparison: /^(so sánh|khác nhau|giống|compare)/,
    procedure: /^(cách làm|how to|làm sao|quy trình)/,
    conversational: /^(chào|hello|hi|cảm ơn|thank)/,
    // ...
  }

  Phân Loại Độ Phức Tạp:
  - length > 50 → complex
  - length > 20 → medium
  - length ≤ 20 → simple

  Xác Định Context Requirements:
  - Types cần context: ['definition', 'explanation', 'comparison',
  'procedure']

  ---
  ⚡ Bước 3: Decision Tree Logic

  if (isConversational):
      return 'direct' (confidence: 0.9)

  elif (isKnowledgeRelated AND relevanceScore > 5):
      if (matchedKeywords > 2 OR needsContext):
          return 'context' (confidence: 0.85)  # Score-based
      else:
          return 'embedding' (confidence: 0.8)  # RAG-based

  elif (isKnowledgeRelated AND relevanceScore > 2):
      return 'embedding' (confidence: 0.7)  # Try RAG

  else:
      return 'direct' (confidence: 0.8)  # No knowledge match

  ---
  📈 Các Thuật Toán Được Chọn

  1. Score Context (context)

  - Khi: Nhiều từ khóa trùng khớp (>2) HOẶC cần context định nghĩa
  - Ưu điểm: Nhanh, chính xác với từ khóa rõ ràng
  - Cơ chế: Tính điểm dựa trên keyword matching, title similarity

  2. RAG Embedding (embedding)

  - Khi: Có liên quan nhưng ít từ khóa trực tiếp
  - Ưu điểm: Tìm được content tương tự ngữ nghĩa
  - Cơ chế: Vector similarity search với cosine distance

  3. Direct Mode (direct)

  - Khi: Câu trò chuyện HOẶC không liên quan kiến thức
  - Ưu điểm: Linh hoạt, dùng AI trực tiếp
  - Cơ chế: GPT với conversation history

  ---
  🎯 Độ Tin Cậy (Confidence Scoring)

  Confidence levels:
  - 0.9: Conversational (rất chắc chắn)
  - 0.85: Context với nhiều keywords (chắc chắn)
  - 0.8: Embedding hoặc Direct với logic rõ ràng
  - 0.7: Embedding với ít evidence (thử nghiệm)
  - 0.5: Fallback/error cases

  ---
  🔧 Tối Ưu Hóa & Điểm Mạnh

  Điểm Mạnh:

  1. Multi-criteria Decision: Kết hợp keyword, semantic, pattern
  matching
  2. Adaptive Thresholds: Điều chỉnh được các ngưỡng quyết định
  3. Fallback Mechanism: Luôn có thuật toán backup
  4. Logging & Analytics: Track decisions để cải thiện
  5. Language Agnostic: Hỗ trợ cả tiếng Việt và tiếng Anh

  Complexity Analysis:

  - Time Complexity: O(K + T + W)
    - K: số keywords, T: số titles, W: số words trong question
  - Space Complexity: O(K + T) cho caching data

  Potential Improvements:

  1. Machine Learning Approach: Train model dựa trên historical data       
  2. Dynamic Thresholds: Tự điều chỉnh threshold theo performance
  3. Context Window: Xem xét previous questions trong session
  4. Semantic Embeddings: Dùng embeddings cho question classification      

  Thuật toán hiện tại cân bằng tốt giữa đơn giản, hiệu quả và chính        
  xác cho use case của chatbot tri thức.